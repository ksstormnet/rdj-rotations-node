{
  "files": [
    {
      "name": "jest.config.ts",
      "content": "import type { Config } from '@jest/types';\n\nconst config: Config.InitialOptions = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src', '<rootDir>/tests'],\n  testMatch: [\n    '**/__tests__/**/*.+(ts|tsx|js)',\n    '**/?(*.)+(spec|test).+(ts|tsx|js)'\n  ],\n  transform: {\n    '^.+\\.(ts|tsx)$': 'ts-jest'\n  },\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov'],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80\n    }\n  },\n  moduleNameMapper: {\n    '^@/(.*)$': '<rootDir>/src/$1'\n  },\n  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],\n  clearMocks: true,\n  maxWorkers: '50%',\n  collectCoverageFrom: [\n    'src/**/*.{js,ts}',\n    '!src/**/*.d.ts',\n    '!src/**/*.config.ts'\n  ],\n  verbose: false,\n  silent: true,\n  reporters: [\n    [\"default\", { \"verbosity\": 0 }]\n  ]\n};\n\nexport default config;"
    },
    {
      "name": "tests/setup.ts",
      "content": "import * as dotenv from \"dotenv\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { mockDeep, mockReset, DeepMockProxy } from \"jest-mock-extended\";\n\n// Load test environment variables\ndotenv.config({ path: \".env.test\" });\n\n// Create a deep mock of PrismaClient\nconst prismaMock = mockDeep<PrismaClient>({\n  $on: jest.fn(),\n});\n\n// Mock the PrismaClient constructor\njest.mock(\"@prisma/client\", () => ({\n  PrismaClient: jest.fn(() => prismaMock),\n}));\n\nbeforeEach(() => {\n  mockReset(prismaMock);\n});\n\nexport { prismaMock };\n\n// Type for mocked context\nexport type MockContext = {\n  prisma: DeepMockProxy<PrismaClient>;\n};\n\n// Helper to create mock context\nexport const createMockContext = (): MockContext => ({\n  prisma: prismaMock,\n});\n\n// Global test setup\nbeforeAll(() => {\n  process.env.NODE_ENV = \"test\";\n});\n\n// Global test teardown\nafterAll(async () => {\n  // Add any global cleanup here\n});\n\n// Custom matchers\nexpect.extend({\n  toBeWithinRange(received: number, floor: number, ceiling: number) {\n    const pass = received >= floor && received <= ceiling;\n    if (pass) {\n      return {\n        message: () =>\n          `expected ${received} not to be within range ${floor} - ${ceiling}`,\n        pass: true,\n      };\n    } else {\n      return {\n        message: () =>\n          `expected ${received} to be within range ${floor} - ${ceiling}`,\n        pass: false,\n      };\n    }\n  },\n});"
    },
    {
      "name": "tests/unit/services/databaseService.test.ts",
      "content": "import { DatabaseService } from \"../../../src/services/databaseService\";\nimport { createMockContext, MockContext, prismaMock } from \"../../setup\";\n\ndescribe(\"DatabaseService\", () => {\n  let mockCtx: MockContext;\n  let dbService: DatabaseService;\n\n  beforeEach(() => {\n    // Clear all mocks before each test\n    jest.clearAllMocks();\n    \n    mockCtx = createMockContext();\n    dbService = new DatabaseService();\n    // Inject our mock\n    (dbService as any).prisma = mockCtx.prisma;\n\n    // Setup default successful responses\n    mockCtx.prisma.$queryRaw.mockResolvedValue([{ \"1\": 1 }]);\n    mockCtx.prisma.$disconnect.mockResolvedValue(undefined);\n  });\n\n  describe(\"connection\", () => {\n    afterEach(async () => {\n      await dbService.disconnect();\n    });\n\n    it(\"should connect to the database\", async () => {\n      const isConnected = await dbService.connect();\n      expect(isConnected).toBe(true);\n      expect(dbService.isConnected()).toBe(true);\n      expect(mockCtx.prisma.$queryRaw).toHaveBeenCalled();\n    });\n\n    it(\"should disconnect from the database\", async () => {\n      await dbService.connect();\n      await dbService.disconnect();\n      expect(dbService.isConnected()).toBe(false);\n      expect(mockCtx.prisma.$disconnect).toHaveBeenCalled();\n    });\n\n    it(\"should handle connection errors gracefully\", async () => {\n      mockCtx.prisma.$queryRaw.mockRejectedValueOnce(\n        new Error(\"Connection failed\"),\n      );\n      await expect(dbService.connect()).rejects.toThrow(\n        \"Database connection failed\",\n      );\n      expect(dbService.isConnected()).toBe(false);\n    });\n  });\n\n  describe(\"health check\", () => {\n    afterEach(async () => {\n      await dbService.disconnect();\n    });\n\n    it(\"should return true when database is healthy\", async () => {\n      await dbService.connect();\n      const isHealthy = await dbService.healthCheck();\n      expect(isHealthy).toBe(true);\n    });\n\n    it(\"should return false when database is not connected\", async () => {\n      const isHealthy = await dbService.healthCheck();\n      expect(isHealthy).toBe(false);\n    });\n\n    it(\"should return false when database query fails\", async () => {\n      await dbService.connect();\n      mockCtx.prisma.$queryRaw.mockRejectedValueOnce(\n        new Error(\"Query failed\"),\n      );\n      const isHealthy = await dbService.healthCheck();\n      expect(isHealthy).toBe(false);\n    });\n  });\n});"
    },
    {
      "name": "tests/integration/rotationDisplay.test.ts",
      "content": "import { DatabaseService } from \"../../src/services/databaseService\";\nimport { RotationRepository } from \"../../src/repositories/rotationRepository\";\nimport { RotationDisplayService } from \"../../src/services/rotationDisplayService\";\n\njest.unmock(\"@prisma/client\");\n\ndescribe(\"Rotation Display Integration\", () => {\n  let dbService: DatabaseService;\n  let rotationRepo: RotationRepository;\n  let displayService: RotationDisplayService;\n\n  beforeAll(async () => {\n    dbService = new DatabaseService();\n    await dbService.connect();\n    rotationRepo = new RotationRepository(dbService);\n    displayService = new RotationDisplayService(dbService);\n  });\n\n  afterAll(async () => {\n    await dbService.disconnect();\n  });\n\n  it(\"should fetch rotation Hr A with items\", async () => {\n    const rotation = await rotationRepo.getRotationByName(\"Hr A\");\n    expect(rotation).not.toBeNull();\n    expect(rotation?.name).toBe(\"Hr A\");\n\n    if (rotation) {\n      const items = await rotationRepo.getRotationItems(rotation.ID);\n      \n      if (process.env.DEBUG) {\n        console.log(\"\\nRotation Hr A Structure:\");\n        console.log(\"-----------------------\");\n        items.forEach((item) => {\n          console.log(\n            `${item.ord}: Category ${item.catID}, Subcategory ${item.subID} - ${item.data}`,\n          );\n        });\n      }\n\n      expect(items.length).toBeGreaterThan(0);\n      expect(items[0].ord).toBe(0);\n      \n      for (let i = 1; i < items.length; i++) {\n        expect(items[i].ord).toBeGreaterThan(items[i - 1].ord);\n      }\n    }\n  });\n});"
    },
    {
      "name": "src/services/databaseService.ts",
      "content": "import { PrismaClient, Prisma } from \"@prisma/client\";\nimport { Logger } from \"../utils/logger\";\n\nexport class DatabaseService {\n  private prisma: PrismaClient;\n  private connected: boolean = false;\n  private readonly logger = new Logger(\"DatabaseService\");\n\n  constructor() {\n    // In test mode, don't log anything\n    if (process.env.NODE_ENV === \"test\") {\n      this.prisma = new PrismaClient({\n        log: [] // No logging in test mode\n      });\n    } else {\n      this.prisma = new PrismaClient({\n        log: [\n          { level: \"query\", emit: \"event\" },\n          { level: \"error\", emit: \"event\" },\n          { level: \"warn\", emit: \"event\" },\n        ]\n      });\n\n      // Only set up event handlers in non-test mode\n      this.prisma.$on('error' as never, (event: Prisma.LogEvent) => {\n        this.logger.error(\"Database error occurred\", event);\n      });\n\n      this.prisma.$on('query' as never, (event: Prisma.QueryEvent) => {\n        this.logger.debug(`Query: ${event.query}`);\n      });\n\n      this.prisma.$on('warn' as never, (event: Prisma.LogEvent) => {\n        this.logger.warn(`Prisma warning: ${event.message}`);\n      });\n    }\n  }\n\n  async connect(): Promise<boolean> {\n    try {\n      await this.prisma.$queryRaw`SELECT 1`;\n      this.connected = true;\n      this.logger.info(\"Successfully connected to database\");\n      return true;\n    } catch (error) {\n      this.connected = false;\n      this.logger.error(\"Failed to connect to database\", error);\n      throw new Error(\n        `Database connection failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      );\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    try {\n      await this.prisma.$disconnect();\n      this.connected = false;\n      this.logger.info(\"Successfully disconnected from database\");\n    } catch (error) {\n      this.logger.error(\"Error disconnecting from database\", error);\n      throw new Error(\n        `Database disconnection failed: ${error instanceof Error ? error.message : \"Unknown error\"}`,\n      );\n    }\n  }\n\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  async healthCheck(): Promise<boolean> {\n    try {\n      if (!this.connected) {\n        return false;\n      }\n      await this.prisma.$queryRaw`SELECT 1`;\n      return true;\n    } catch (error) {\n      this.logger.error(\"Health check failed\", error);\n      return false;\n    }\n  }\n\n  getPrismaClient(): PrismaClient {\n    if (!this.connected) {\n      throw new Error(\"Database is not connected\");\n    }\n    return this.prisma;\n  }\n}"
    },
    {
      "name": "src/repositories/rotationRepository.ts",
      "content": "import { PrismaClient } from '@prisma/client';\nimport { Rotation } from '../models/rotation';\nimport { RotationList } from '../models/rotationList';\nimport { DatabaseService } from '../services/databaseService';\n\nexport class RotationRepository {\n  private dbService: DatabaseService;\n\n  constructor(dbService: DatabaseService) {\n    this.dbService = dbService;\n  }\n\n  private get prisma(): PrismaClient {\n    return this.dbService.getPrismaClient();\n  }\n\n  async getRotationByName(name: string): Promise<Rotation | null> {\n    const rotationData = await this.prisma.rotations.findFirst({\n      where: { name }\n    });\n\n    if (!rotationData) return null;\n\n    return new Rotation(rotationData);\n  }\n\n  async getRotationItems(rotationId: number): Promise<RotationList[]> {\n    const items = await this.prisma.rotations_list.findMany({\n      where: { pID: rotationId },\n      orderBy: { ord: 'asc' }\n    });\n\n    return items.map(item => new RotationList({\n      ...item,\n      ID: item.ID,\n      pID: item.pID,\n      catID: item.catID,\n      subID: item.subID,\n      genID: item.genID,\n      ord: item.ord,\n      data: item.data,\n      repeatRule: item.repeatRule,\n      selType: item.selType,\n      sweeper: item.sweeper,\n      track_separation: item.track_separation,\n      artist_separation: item.artist_separation,\n      title_separation: item.title_separation,\n      album_separation: item.album_separation\n    }));\n  }\n}"
    },
    {
      "name": "src/services/rotationDisplayService.ts",
      "content": "import { RotationRepository } from '../repositories/rotationRepository';\nimport { DatabaseService } from './databaseService';\n\nexport class RotationDisplayService {\n  private rotationRepo: RotationRepository;\n  private dbService: DatabaseService;\n\n  constructor(dbService: DatabaseService) {\n    this.dbService = dbService;\n    this.rotationRepo = new RotationRepository(dbService);\n  }\n\n  async displayRotation(name: string): Promise<void> {\n    try {\n      const rotation = await this.rotationRepo.getRotationByName(name);\n      if (!rotation) {\n        console.log(`Rotation \"${name}\" not found`);\n        return;\n      }\n\n      const items = await this.rotationRepo.getRotationItems(